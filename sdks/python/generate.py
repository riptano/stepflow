#!/usr/bin/env python3
# Licensed to the Apache Software Foundation (ASF) under one or more contributor
# license agreements.  See the NOTICE file distributed with this work for
# additional information regarding copyright ownership.  The ASF licenses this
# file to you under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License.  You may obtain a copy of
# the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations under
# the License.

"""Type generation script for StepFlow Python SDK.

This script generates the protocol and flow types from the JSON schemas.
"""

import argparse
import subprocess
import sys
import tempfile
from pathlib import Path


def _generate_types_content(schema_name: str, verbose: bool = True) -> str:
    """Generate types from a schema file and return the processed content."""
    # Get paths
    script_dir = Path(__file__).parent
    project_root = script_dir.parent.parent
    schema_path = project_root / "schemas" / f"{schema_name}.json"

    # Check that schema exists
    if not schema_path.exists():
        raise FileNotFoundError(f"Schema file not found at {schema_path}")

    if verbose:
        print(f"Generating {schema_name} types from {schema_path}")

    # Generate to temporary file
    with tempfile.NamedTemporaryFile(mode="w", suffix=".py") as temp_file:
        temp_path = Path(temp_file.name)

        # Run datamodel-code-generator
        cmd = [
            "python",
            "-m",
            "datamodel_code_generator",
            "--input",
            str(schema_path),
            "--output",
            str(temp_path),
            "--input-file-type",
            "jsonschema",
            "--output-model-type",
            "msgspec.Struct",
            "--field-constraints",
            "--use-union-operator",
            "--keyword-only",
            "--target-python-version",
            "3.11",
        ]

        # Use --use-title-as-name for both schemas since both now have valid class name titles
        # protocol.json: "JsonRpcVersion", "InitializeParams", "ComponentExecuteResult", etc.
        cmd.append("--use-title-as-name")

        if verbose:
            print(f"Running: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            raise RuntimeError(f"Error generating {schema_name}: {result.stderr}")

        if verbose:
            print("✓ Generated to temporary file")

        # Process the generated file to add license header and remove timestamp
        if verbose:
            print(f"Processing generated {schema_name} file...")

        with open(temp_path) as f:
            content = f.read()

        # Parse the content
        lines = content.split("\n")

        # Remove the original generator header and timestamp
        filtered_lines = []
        skip_until_imports = True

        for line in lines:
            # Skip generated header and timestamp lines
            if (
                line.startswith("# generated by datamodel-codegen:")
                or line.startswith("#   filename:")
                or line.startswith("#   timestamp:")
            ):
                continue

            # When we hit the first import, stop skipping
            if line.startswith("from __future__"):
                skip_until_imports = False

            if not skip_until_imports:
                filtered_lines.append(line)

        # Create the license header
        license_header = [
            "# Licensed to the Apache Software Foundation (ASF) under one or more contributor",
            "# license agreements.  See the NOTICE file distributed with this work for",
            "# additional information regarding copyright ownership.  The ASF licenses this",
            '# file to you under the Apache License, Version 2.0 (the "License"); you may not',
            "# use this file except in compliance with the License.  You may obtain a copy of",
            "# the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            '# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT',
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the",
            "# License for the specific language governing permissions and limitations under",
            "# the License.",
            "",
            f"# Auto-generated {schema_name} types from schemas/{schema_name}.json",
            "# To regenerate this file, run:",
            "#   uv run python generate.py",
            "",
        ]

        # Combine license header with the filtered content
        new_content = "\n".join(license_header + filtered_lines)

        # Fix forward references for recursive types
        new_content = new_content.replace(
            "List[ValueTemplate]", "List['ValueTemplate']"
        )
        new_content = new_content.replace(
            "Dict[str, ValueTemplate]", "Dict[str, 'ValueTemplate']"
        )

        if verbose:
            print("✓ Added license header and generation documentation")
            print(f"✓ {schema_name.capitalize()} generation complete!")

        return new_content


def generate_types_from_schema(
    schema_name: str, output_filename: str, check_only: bool = False
) -> int:
    """Generate types from a schema file."""
    # Get paths
    script_dir = Path(__file__).parent
    output_path = script_dir / "src" / "stepflow_py" / output_filename

    try:
        print(f"Generating {schema_name} types...")
        new_content = _generate_types_content(schema_name, verbose=False)

        if check_only:
            # Compare with existing file
            if output_path.exists():
                with open(output_path) as f:
                    existing_content = f.read()

                if existing_content != new_content:
                    print(f"❌ {schema_name} types are out of date!")
                    return 1
                else:
                    print(f"✅ {schema_name} types are up to date")
            else:
                print(f"❌ {schema_name} types file does not exist!")
                return 1
        else:
            # Write the final content
            with open(output_path, "w") as f:
                f.write(new_content)

    except (FileNotFoundError, RuntimeError) as e:
        print(f"Error: {e}")
        return 1

    return 0


def main():
    """Generate protocol types from JSON schema (flow types are now included in protocol)."""
    parser = argparse.ArgumentParser(
        description="Generate StepFlow Python SDK types from JSON schemas"
    )
    parser.add_argument(
        "--check", action="store_true", help="Check if generated files are up to date"
    )

    args = parser.parse_args()

    # Generate protocol types (includes Flow and all other types)
    result = generate_types_from_schema(
        "protocol", "generated_protocol.py", check_only=args.check
    )
    if result != 0:
        return result

    return 0


if __name__ == "__main__":
    sys.exit(main())
